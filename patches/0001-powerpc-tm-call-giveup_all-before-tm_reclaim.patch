From 1c63b9e3ddc6bfe977f6b9148bc038371c425432 Mon Sep 17 00:00:00 2001
From: Gustavo Romero <gromero@linux.vnet.ibm.com>
Date: Fri, 16 Jun 2017 17:58:43 -0400
Subject: [PATCH] powerpc/tm: call giveup_all() before tm_reclaim()

The moving up of giveup_all() in this commit amounts to set correctly
fp_state, vr_state (used to keep the live speculated state values of
f0-31/vs0-31 and v0-31/vs32-63, respectively), and ckpt_regs.msr before
treclaiming, when the ckfp_state content and the ckvr_state content
are set from the fp_state/vr_state or from the checkpoint area using
the correct msr value taken from regs->msr.

For instance, if we take an fp_unavailable whilst in a transaction
and at the same time MSR.VEC=1 we'll end up in fp_unavailable_tm()
and tm_reclaim_thread() will be called to reclaim the checkpointed
state in the checkpoint area. Now once in tm_reclaim_thread() if we
don't do the giveup_all() before the tm_reclaim() then the speculated
live state values are lost. Furthermore, ckpt_regs.msr wont'be set
correctly and tm_reclaim() won't get told about MSR.VEC=1 and so it
wont't backup into ckvr_state the checkpointed vector (VMX) registers,
i.e. the vector register values before entering in transactional mode.

The same would happen for the fp registers if MSR.FP=1 were set instead.

Signed-off-by: Gustavo Romero <gromero@linux.vnet.ibm.com>
Signed-off-by: Breno Leitao <leitao@debian.org>
Signed-off-by: Cyril Bur <cyrilbur@gmail.com>
---
 arch/powerpc/kernel/process.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c
index 2ad725e..9500b07 100644
--- a/arch/powerpc/kernel/process.c
+++ b/arch/powerpc/kernel/process.c
@@ -864,6 +864,14 @@ static void tm_reclaim_thread(struct thread_struct *thr,
 	if (!MSR_TM_SUSPENDED(mfmsr()))
 		return;
 
+	/* Save all register sets under use in userspace (FP/VEC/VSX)
+	 * into its proper thread struct and copy regs.msr to ckpt_regs.msr
+	 * so it's correct when used below, reflecting the correct state of
+	 * the msr register in userspace just before entering in kernel
+	 * space.
+	 */
+	giveup_all(container_of(thr, struct task_struct, thread));
+
 	/*
 	 * If we are in a transaction and FP is off then we can't have
 	 * used FP inside that transaction. Hence the checkpointed
@@ -883,8 +891,6 @@ static void tm_reclaim_thread(struct thread_struct *thr,
 		memcpy(&thr->ckvr_state, &thr->vr_state,
 		       sizeof(struct thread_vr_state));
 
-	giveup_all(container_of(thr, struct task_struct, thread));
-
 	tm_reclaim(thr, thr->ckpt_regs.msr, cause);
 }
 
-- 
2.7.4

